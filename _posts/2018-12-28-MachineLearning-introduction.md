---
layout: post
title: "机器学习系列（一）基本术语"
date: 2018-12-28
description: "机器学习基本术语"
tag: 机器学习
---

### 机器学习术语

机器学习正是这样一门学科，它致力于研究如何通过计算的手段，利用经验来改善系统自身的性能.在计算机系统中，“经验”通常以“数据”形式存在，因此，机器学习所研究的主要内容，是关于在计算机上从数据中产生“模 型”（model)的算法，即“学习算法”（learning algorithm).有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时(例 如看到一个没剖开的西瓜)，模型会给我们提供相应的判断(例如好瓜).如果说计算机科学是研究关于“算法”的学问，那么类似的，可以说机器学习是研究关于`“学习算法”`的学问。

### 基本术语

| 编号 | 色泽 | 根蒂 | 敲声 | 好瓜 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 青绿 | 蜷缩 | 浊响 | 是   |
| 2    | 乌黑 | 蜷缩 | 浊响 | 是   |
| 3    | 青绿 | 硬挺 | 清脆 | 否   |
| 4    | 乌黑 | 稍蜷 | 沉闷 | 否   |

#### **数据集（data set）**

这组记录的集合称为一个`数据集（data set）`

#### **示例”（instance)、样 本”（sample)**

其中每条记录是关于一个事件或对象(这里是一个西瓜)的描述，称为一个`“示例”（instance`)或“`样 本”（sample)`.有时整个数据集亦称一个“样本”，因为它可看作对样本空间的一个采样; 通过上下文可判断出“样本”是指单个示例还是数据集。

#### **属性（attribute）、特征（feature）**

反映事件或对象在某方面的表现或性质的事项，例如“色泽” “根蒂”“敲声”，称为`“属性”（attribute)`或`“特征”（feature).`

#### **属性值（attribute value）**

属性上的取值，例如“青绿”“乌黑”，称为“`属性值”（attribute value)`“.

#### **“属性空间”（attribute space)、“样本空间”（sample space)或“输入空间”**

属性合成的空间称为`“属性空间”（attribute space)、“样本空间”（sample space)或“输入空间`”

![属性空间](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/29093845.jpg)

#### **特征向量（feature vector）**

例如我们把“色泽” “根蒂” “敲声”作为三个坐标轴，则它们张成 一个用于描述西瓜的三维空间，每个西瓜都可在这个空间中找到自己的坐标位 置.由于空间中的每个点对应一个坐标向量，因此我们也把一个示例称为一个 `“特征向量”（feature vector)`.

#### **维数（dimensionality）**

一般地，令* D * = {$x_1$ ,$x_2$, ...，$x_m$}表示包含m个示例的数据集，每个示例由d个属性描述(例如上面的西瓜数据使用了3个属性)，则每个示例 $x_i$ =($x_i1$;$x_i2$;...x_id）是d维样本空间* X* 中的一个向量，$x_i \in $* X * ,其中$x_ij$ 是$x_i$在第j个属性上的取值(例如上述第3个西瓜在第2个属性上的值是“硬挺”），* d * 称为样本$x_i$的 `“维数”（dimensionality).`

#### **学习、训练、训练数据、训练样本、训练集、假设、真相、真实、学习器**

从数据中学得模型的过程称为`“学习”（learning)`或`“训练”（training),` 这个过程通过执行某个学习算法来完成.训练过程中使用的数据称为“`训练 数据”（training data)`，其中每个样本称为一个`“训练样本”（training sample),` 训练样本组成的集合称为`“训练集”（training set)`.学得模型对应了关于数据的某种潜在的规律，因此亦称`假设”（hypothesis)`;这种潜在规律自身，则称为`“真相”`或`“真实” (ground-tmth),`学习过程就是为了找出或逼近真相.有时将模型称为`“学习器”（learner)`,可看作学习算法在给定数据和参数空间上的实例化.

#### **“训练示例” （training instance)、“训练例”**

训练样本亦称`“训练示例” （training instance)或“训练例”`.

#### **预测、标记、样例、标记空间、输出空间**

学习算法通常有参数需设置，使用不同的参数值 和(或)训练数据，将产生不同的结果.

如果希望学得一个能帮助我们判断没剖开的是不是“好瓜”的模型，仅有前面的示例数据显然是不够的.要建立这样的关于<font color=#00ffff size=5>“预测”（prediction)</font>的模型，我们需获得训练样本的“结果”信息，例如“((色泽=青绿;根蒂=蜷缩; 敲声=浊响)，好瓜这里关于示例结果的信息，例如“好瓜”，称为<font color=#00ffff size=5>“标记”（label)</font>;拥有了标记信息的示例，则称为<font color=#00ffff size=5>“样例”（example)</font>.—般地，用($x_i$，$y_i$）表示第i个样例，其中队$y_i \in$ * y * 是示例$x_i$的标记，* y * 是所有标记的集合, 亦称<font color=#00ffff size=5>“标记空间”（label space)</font>或<font color=#00ffff size=5>“输出空间”</font>.

> 将“label”译为“标记”而非“标签”，是考虑到英文中“label”既可用作名词、也可用作动词.若将标记看作对象本身的一部分，则“样例”有时也称为“样本”.

#### 分类、回归、二分类、正类、反类、多分类

若我们欲预测的是离散值，例如“好瓜”“坏瓜”，此类学习任务称为<font color=#00ffff size=5>“分类”（classification)</font>;若欲预测的是连续值，例如西瓜成熟度0.95、0.37, 此类学习任务称为<font color=#00ffff size=5>“回归”（regression)</font>.对只涉及两个类别的<font color=#00ffff size=5>“二分类”（binary classification)</font>任务，通常称其中一个类为<font color=#00ffff size=5>“正类”（positive class)</font>, 另一个类为<font color=#00ffff size=5>“反类'(negative class)</font>;涉及多个类别时，则称为<font color=#00ffff size=5>“多分类”（multi-class classification)</font>任务.一般地，预测任务是希望通过对训练集{($x_1,y_1$),($x_2,y_2$)，...，($x_m,y_m$)}进行学习，建立一个从输入空间 * x * 到输出空间$y$的映射$f$:$X \longmapsto Y $ 对二分类任务，通常令$y$ = {-1, +1}或{0, 1};对多分类任务，|$y$|> 2;对回归任务,$y$ = $R$，$R$为实数集.



> 学得模型后，使用其进行预测的过程称为“测试”（testing)，被预测的样本 称为“测试样本”（testing sample).例如在学得$f$后，对测试例$x$可得到其预 测标记$y = f(x)$
>
> 亦称“测试示例”（testing instance） 或“测试例”



#### **聚类、簇**

我们还可以对西瓜做<font color=#00ffff size=5>“聚类”（clustering)</font>，即将训练集中的西瓜分成若干 组，每组称为一个<font color=#00ffff size=5>“簇”（cluster)</font>;这些自动形成的簇可能对应一些潜在的概念划分，例如“浅色瓜”“深色瓜”，甚至“本地瓜”“外地瓜”.这样的学习过程有助于我们了解数据内在的规律，能为吏深入地分析数据建立基础.需说明 的是，在聚类学习中，“浅色瓜” “本地瓜”这样的概念我们事先是不知道的， 而且学习过程中使用的训练样本通常不拥有标记信息.



#### 监督学习、无监督学习

根据训练数据是否拥有标记信息，学习任务可大致划分为两大类：<font color=#00ffff size=5>“监督学习 ”（supervised learning)</font>和<font color=#00ffff size=5>“无监督学习 ”（unsupervised learning)</font>,分类和回归是前者的代表，而聚类则是后者的代表.

> 亦称“有导师学习”和“无导师学习”

#### **泛化能力**

需注意的是，机器学习的目标是使学得的模型能很好地适用于“新样本”, 而不是仅仅在训练样本上工作得很好；即便对聚类这样的无监督学习任务，我们也希望学得的簇划分能适用于没在训练集中出现的样本.学得模型适用于新样本的能力，称为<font color=#00ffff size=5>“泛化”（generalization)能力</font>.具有强泛化能力的模型能 很好地适用于整个样本空间.于是，尽管训练集通常只是样本空间的一个很小的采样，我们仍希望它能很好地反映出样本空间的特性，否则就很难期望在训练集上学得的模型能在整个样本空间上都工作得很好.通常假设样本空间中全 体样本服从一个未知“分布”（distribution)$D$，我们获得的每个样本都是独立地从这个分布上采样获得的，即“独立同分布”（independent and identically distributed，简称$i.i.d.$). —般而言，训练样本越多，我们得到的关于$D$的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型.

#### 总结

![基本术语](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/57777708.jpg)

### 假设空间

`归纳(induction)`与`演绎(deduction)`是科学推理的两大基本手段。前者是从特殊到一般的“泛`化”（generalization)过程`，即从具体的事实归结出一般性规律；后者则是从一般到特殊的`“特化”（specialization)过程`，即从基础原理推演 出具体状况.例如，在数学公理系统中，基于一组公理和推理规则推导出与之相洽的定理，这是演绎;而“从样例中学习”显然是一个归纳的过程，因此亦称 `“归纳学习 ”（inductive learning)` 。

归纳学习有`狭义与广义`之分，广义的归纳学习大体相当于从样例中学习， 而狭义的归纳学习则要求从训练数据中学得概念(concept)，因此亦称为`“概念 学习”或“概念形成”`.概念学习技术目前研究、应用都比较少，因为要学得 泛化性能好且语义明确的概念实在太困难了，现实常用的技术大多是产生“黑 箱”模型.然而，对概念学习有所了解，有助于理解机器学习的一些基础思想.

概念学习中最基本的是布尔概念学习，即对“是”“不是”这样的可表示 为0/1布尔值的目标概念的学习。

| 编号 | 色泽 | 根蒂 | 敲声 | 好瓜 |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 青绿 | 蜷缩 | 浊响 | 是   |
| 2    | 乌黑 | 蜷缩 | 浊响 | 是   |
| 3    | 青绿 | 硬挺 | 清脆 | 否   |
| 4    | 乌黑 | 稍蜷 | 沉闷 | 否   |

>  (色泽=?)⋀(根蒂=?)⋀(敲声=?)↔好瓜

学习过程⟶⟶ 在所有假设(hypothesis)组成的空间中进行搜索的过程

`目标:` 找到与训练集“匹配”(fit)的假设

以西瓜问题假设为例。色泽属性可取（青绿，乌黑，浅白，\* ），根蒂属性可取（蜷缩，稍蜷，硬挺，\* ），敲声属性可取（浊响，清脆，沉闷，\* ），以及好瓜假设不存在($\phi$)。即西瓜问题的假设空间大小为（4 \* 4 \* 4 + 1=65）

![假设空间](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/55864726.jpg)

#### **版本空间**

可以有许多策略对这个假设空间进行搜索，例如自顶向下、从一般到特殊， 或是自底向上、从特殊到一般，搜索过程中可以不断删除与正例不一致的假设、和(或)与反例一致的假设.最终将会获得与训练集一致(即对所有训练样本 能够进行正确判断)的假设，这就是我们学得的结果.

需注意的是，现实问题中我们常面临很大的假设空间，但学习过程是基于有限样本训练集进行的，因此，可能有多个假设与训练集一致，即存在着一个与训练集一致的“假设集合”，我们称之为<font color=#00ffff size=5>“版本空间”（version space)</font>

![版本空间](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/10121402.jpg)

### 归纳偏好

通过学习得到的模型对应了假设空间中的一个假设.于是，上面西瓜版本空间给我们带来一个麻烦：现在有三个与训练集一致的假设，但与它们对应的模型在面临新样本的时候，却会产生不同的输出.例如，对(色泽=青绿; 根蒂=蜷缩；敲声=沉闷)这个新收来的瓜，如果我们采用的是“好瓜$\longleftrightarrow$(色泽=\* )$\wedge$（根蒂=蜷缩）$\wedge$（敲声= \* )”，那么将会把新瓜判断为好瓜，而如果釆用了另外两个假设，则判断的结果将不是好瓜.那么，应该采用哪一个模型(或 假设)呢？

若仅有以上的训练样本，则无法断定上述三个假设中哪一个“更好”.
然而，对于一个具体的学习算法而言，它必须要产生一个模型.这时，学习算法本身的“偏好”就会起到关键的作用.例如，若我们的算法喜欢“尽可能特殊”的模型，则它会选择“好瓜$\longleftrightarrow$(色泽=\* )$\wedge$(根蒂=蜷缩）$\wedge$(敲声=浊响)”； 但若我们的算法喜欢“尽可能一般”的模型，并且由于某种原因它更“相信” 根蒂，则它会选择“好瓜$\longleftrightarrow$ (色泽=\* )$\wedge$(根蒂=蜷缩)$\wedge$(敲声=\* )” .机器学习算法在学习过程中对某种类型假设的偏好，称为“归纳偏好”（inductive bias), 或简称为“偏好'

![归纳偏好](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/15099462.jpg)

> “奥卡姆剃刀”（Occam’s razor)是一种常用的、自然科学研究中最基本的原则，即“若有多个假设与观察一致，则选最简单的那个”.如果采用这个原则，并且假设我们认为“更平滑”意味着“更简单”（例如曲线 A更易于描述，其方程式是$y=-x^2 + 6x + 1$，而曲线B则要复杂得多)

![没有午餐定理](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/52317858.jpg)

No Free Lunch Theoren 定理 ， 没有免费的午餐定理，简称NFL定理， 由美国斯坦福大学的Wolpert和Macready教授提出。

> NFL定理：一个算法A若在某些问题上比另一个算法B好，必存在另一些问题B比A好

为简单起见，假设样本空间$X$和假设空间$H$都是离散的.令$P(h|X,L_a)$代表算法$L_a$基于训练数据X产生假设$h$的概率，再令$f$代表我们希望学习的真实目标函数$L_a$的“训练集外误差”，即$L_a$在训练集之外的所有样本上的误差为

#### $E_{ote}(L_a|X,f) = \sum_{h}\sum_{x\in\chi-X}P(x)\mathbb{I}(h(x)\neq f(x))P(h|X,L_a)$

其中$\mathbb{I}(\cdot)$是指示函数，若•为真则取值1,否则取值0.

考虑二分类问题，且真实目标函数可以是任何函数$x \longmapsto {0,1}$,函数空间为${0,1}^{|x|}$对所有可能的f按均匀分布对误差求和，有

#### $\sum_{f}E_{ote}(L_a|X,f)=\sum_{f}\sum_{h}\sum_{x\in\chi-X}P(x)\mathbb{I}(h(x)\neq f(x))P(h|X,L_a)$

#### $=\sum_{x\in\chi-X}P(x)\sum_{h}P(h|X,L_a)\sum_{f}\mathbb{I}(h(x)\neq f(x))$ 

#### $=\sum_{x\in\chi-X}P(x)\sum_{h}P(h|X,L_a)\frac{1}{2}2 ^{|x|}$

#### $=\frac{1}{2}2 ^{|x|}\sum_{x\in\chi-X}P(x)\sum_{h}P(h|X,L_a)$

####  $=\frac{1}{2}2 ^{|x|}\sum_{x\in\chi-X}P(x)\cdot 1$ 

> 上式显示出，总误差和学习算法无关！对于任意两个学习算法$L_a$和$L_b$,我们都有

#### $\sum_{f}E_{ote}(L_a|X,f)=\sum_{f}E_{ote}(L_b|X,f)$

也就是说，无论学习算法$L_a$多聪明、学习算法$L_b$多笨拙，它们的期望性能竟然相同！这就是“没有免费的午餐”定理（No FYee Lunch Theorem,简称NFL定理）[Wolpert，1996; Wolpert and Macready, 1995].

#### 总结

NFL定理有一个重要前提：所有“问题”出现的机会相同、或所有问题同等重要.但实际情形并不是这样.很多时候，我们只关注自己正在试图解决的问题(例如某个具体应用任务)，希望为它找到一个解决方案， 至于这个解决方案在别的问题、甚至在相似的问题上是否为好方案，我们并不关心.例如，为了快速从A地到达B地，如果我们正在考虑的A地是南京鼓楼、B地是南京新街口，那么“骑自行车”是很好的解决方案；这个方案对A 地是南京鼓楼、B地是北京新街口的情形显然很糟糕，但我们对此并不关心.



NFL定理最重要的寓意，是让我们清楚地认识到，脱离具体问题，空泛地谈论“什么学习算法更好”毫无意义，因为若考虑所有潜在的问题，则所有学习算法都一样好.要谈论算法的相对优劣，必须要针对具体的学习问题；在某些问题上表现好的学习算法，在另一些问题上却可能不尽如人意，学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用.

### 经验误差和过拟合

通常我们把分类错误的样本数占样本总数的比例称为<font color=#00ffff size=5>“错误率”（error rate)</font>,即如果在m个样本中有a个样本分类错误，则错误率$E$=a/m;相应的, l-a/m称为<font color=#00ffff size=5>“精度” (accuracy)</font>,即“精度=1-错误率”.更一般地,我们把学习器的实际预测输出与样本的真实输出之间的差异称为<font color=#00ffff size=5>“误差”（error)</font>, 学习器在训练集上的误差称为<font color=#00ffff size=5>“训练误差”（training error)</font>或<font color=#00ffff size=5>“经验误差” (empirical error)</font>,在新样本上的误差称为<font color=#00ffff size=5>“泛化误差”（generalization error)</font>.显然，我们希望得到泛化误差小的学习器.然而，我们事先并不知道新样本是什么样，实际能做的是努力使经验误差最小化.在很多情况下，我们可以学得一个经验误差很小、在训练集上表现很好的学习器，例如甚至对所有训练 样本都分类正确，即分类错误率为零，分类精度为100%,但这是不是我们想要的学习器呢？遗憾的是，这样的学习器在多数情况下都不好.

我们实际希望的，是在新样本上能表现得很好的学习器.为了达到这个目的，应该从训练样本中尽可能学出适用于所有潜在样本的“普遍规律”，这样才能在遇到新样本时做出正确的判别.然而,当学习器把训练样本学得“太好”了的时候，很可能已经把训练样本自身的一些特点当做了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。这种现象在机器学习中称为 <font color=#00ffff size=5>“过拟合”（overfitting)</font>.与“过拟合”相对的是<font color=#00ffff size=5>“欠拟合”（underfitting)</font>,这是指对训练样本的一般性质尚未学好。

![过拟合](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/82452214.jpg)

#### 总结

有多种因素可能导致过拟合，其中最常见的情况是由于学习能力过于强大,以至于把训练样本所包含的不太一般的特性都学到了，而欠拟合则通常是由于学习能力低下而造成的.欠拟合比较容易克服，例如在决策树学习中扩展分支、在神经网络学习中増加训练轮数等，而过拟合则很麻烦.在后面的学习中我们将看到，过拟合是机器学习面临的关键障碍，各类学习算法都必然带有一些针对过拟合的措施;然而必须认识到，过拟合是无法彻底避免的，我们所能做的只是“缓解”，或者说减小其风险.



在现实任务中，我们往往有多种学习算法可供选择，甚至对同一个学习算法，当使用不同的参数配置时，也会产生不同的模型.那么，我们该选用哪一个学习算法、使用哪一种参数配置呢？这就是机器学习中的“模型选择”（model selection)问题.理想的解决方案当然是对候选模型的泛化误差进行评估，然后选择泛化误差最小的那个模型.然而如上面所讨论的，我们无法直接获得泛化误差，而训练误差又由于过拟合现象的存在而不适合作为标准，那么，在现实中如何进行模型评估与选择呢？



如何获得测试结果？ ⟹⟹ 评估方法

如何评估性能优劣？ ⟹⟹ 性能度量

如何判断实质差别？ ⟹⟹ 比较检验



### 评估方法

测试集应该与训练集“互斥”

* 留出法 (hold-out)
* 交叉验证法 (cross validation)
* 自助法 (bootstrap)

#### 留出法

<font color=#00ffff size=5>留出法（hold-out)</font>直接将数据集D划分为两个互斥的集合，其中一个集合S作为训练集另一个作为测试集T,即$D = S\cup T$, $S \cap T = \phi$在$S$上训练出模型后，用T来评估其测试误差，作为对泛化误差的估计.



#### 交叉验证法

<font color=#00ffff size=5>“交叉验证法”（cross validation)</font>先将数据集$D$划分为k个大小相似的互斥子集，即$D = D_1\cup D_2\cup ... \cup D_k$ , $D_i \cap D_J = \phi$($i \neq j $)每个子集$D_i$都尽可能保持数据分布的一致性，即从$D$中通过分层采样得到.然后，每次用 k - 1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得k组训练/测试集，从而可进行k次训练和测试，最终返回的是这k个测试结果的均值.显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于k的取值，为强调这一点，通常把交叉验证法称为“k折交叉验证”（k-fold cross validation). k最常用的取值是10,此时称为10折交叉验证。

![10折交叉验证](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/64932491.jpg)

假定数据集$D$中包含m个样本，若令k = m，则得到了交叉验证法的一个特例：<font color=#00ffff size=5>留一法(Leave-One-Out，简称LOO)</font>.显然，留一法不受随机样本划分方式的影响，因为m个样本只有唯一的方式划分为m个子集每个子集包含一个样本；留一法使用的训练集与初始数据集相比只少了一个样本，这就使得在绝大多数情况下，留一法中被实际评估的模型与期望评估的用训练出的模型很相似.因此，留一法的评估结果往往被认为比较准确.然而，留一法也有其缺陷：在数据集比较大时，训练m个模型的计算开销可能是难以忍受的(例如数 据集包含1百万个样本，则需训练1百万个模型)，而这还是在未考虑算法调参的情况下.另外，留一法的估计结果也未必永远比其他评估方法准确；“没有免费的午餐”定理对实验评估方法同样适用.

#### 扩展

我们希望评估的是用𝐷D训练出的模型.但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集比D小，这必然会引入一些因训练样本规模不同而导致的估计偏差.留一法受训练样本规模变化的影响较小，但计算复杂度又太高了.有没有什么办法可以减少训练样本规模不同造成的影响，同时还能比较高效地进行实验估计呢？

#### 自助法

<font color=#00ffff size=5>“自助法”（bootstrapping)</font>是一个比较好的解决方案，它直接以自助采样 法(bootstrap sampling)为基础[Efron and Tibshirani, 1993].给定包含m个样本的数据集$D$,我们对它进行釆样产生数据集$D'$：每次随机从乃中挑选一个样本，将其拷贝放入$D'$,然后再将该样本放回初始数据集$D$中,使得该样本在下次釆样时仍有可能被采到;这个过程重复执行m次后，我们就得到了包含m个样本的数据集$D'$，这就是自助采样的结果.显然，D中有一部分样本会在$D'$中多次出现，而另一部分样本不出现.可以做一个简单的估计，样本在m次采样中始终不被采到的概率是$(1-\frac{1}{m})^m$,取极限得到。

#### $\lim_{m \to \infty} (1-\frac{1}{m})^m \longrightarrow \frac{1}{e} \thickapprox 0.368$

即通过自助釆样，初始数据集乃中约有36.8%的样本未出现在釆样数据集$D'$中，于是我们可将$D'$用作训练集，$D/D'$用作测试集;这样，实际评估的模型与期望评估的模型都使用m个训练样本，而我们仍有数据总量约1/3的、没在训练集中出现的样本用于测试.这样的测试结果，亦称<font color=#00ffff size=5>“包外估计”（out-of-bag estimate)</font>.

> 自助法在数据集较小、难以有效划分训练/测试集时很有用;此外，自助法能从初始数据集中产生多个不同的训练集，这对集成学习等方法有很大的好处. 然而，自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差.因此,在初始数据量足够时，留出法和交叉验证法更常用一些.

### 性能度量

对学习器的泛化性能进行评估，不仅需要有效可的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是<font color=#00ffff size=5>性能度量(performance measure)</font>.性能度量反映了任务需求，在对比不同模型的能力时，使用不同的性能度量往 往会导致不同的评判结果；这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求.

在预测任务中，给定样例集$D = {(x_1，y_1),(x_2,y_2),...,(x_m.y_m)}$,其中$y_i$是示例$x_i$的真实标记.要评估学习器$f$的性能，就要把学习器预测结果$f(x)$与真实标记$y$进行比较.

回归任务最常用的性能度量是<font color=#00ffff size=5>“均方误差”（mean squared error)</font>

#### $E(f;D)=\frac{1}{m}\sum^m_{i=1}(f(x_i)-y_i)^2 $

对于数据分布$D$和概率密度函数$p(\cdot)$,均方误差可描述为

#### $E(f;D)=\int_{x\sim D}（f(x)-y）^2p(x)dx$

<font color=#00ffff size=5>错误率</font>是分类错误的样本数占样本总数的比例

#### $E(f;D)=\frac{1}{m}\sum^m_{i=1}\mathbb{I}(f(x_i)\ne y_i)$

<font color=#00ffff size=5> 精度</font>则是分类正确的样本数占样本总数的比例

#### $acc(f;D)=\frac{1}{m}\sum^m_{i=1}\mathbb{I}(f(x_i) = y_i)$

#### 错误率：

#### $E(f;D)=\int_{x\sim D}\mathbb{I}（f(x) \ne y）p(x)dx$

![混淆矩阵](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/30344968.jpg)

#### 查准率：$P=\frac{TP}{TP+FP}$

#### 查全率：$R=\frac{TP}{TP+FN}$

> 查准率和查全率是一对予盾的度量，一般来说，查准率高时，查全率往往偏低查全率高时.查准率偏低。



### PR图，BEP（Break-Event Point）

根据学习器的预测结果按正例可能性大小对样例进行排序，并逐个把样本作为正例进行预测

![pr图](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/5696241.jpg)

比 BEP 更常用的 F1 度量：

#### F1：$F1=\frac{2PR}{P+R}=\frac{2TP}{样例总数+TP-TN}$

若对查准率/查全率有不同偏好：

#### $F_\beta=\frac{(1+\beta^2)PR}{(\beta^2P)+R}$

> $\beta = 1$时退化为标准的F1；$\beta>1$时查全率有更大影响；$\beta<1$时查准率有更大影响。

#### 扩展

很多时候我们有多个二分类混淆矩阵

**`宏`**

#### $macro-P=\frac{1}{n}\sum^n_{i=1}P_i$

#### $macro-R=\frac{1}{n}\sum^n_{i=1}R_i$

#### $macro-F1=\frac{2macro-P \times macro-R}{macro-P + macro-R}$

**`微`**

#### $micro-P=\frac{\overline{PT}}{\overline{TP}+\overline{FP}}$

#### $micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}$

#### $macro-F1=\frac{2macro-P \times macro-R}{macro-P + macro-R}$

### ROC 与 AUC

> ROC全称是“受试者工作特征”（Receiver Operating Characteristic）。ROC曲线的面积就是AUC（Area Under the Curve）

![ROC和AUC](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/4710690.jpg)

#### $TPR=\frac{TP}{TP+FN}$

#### $FPR=\frac{FP}{TN+FP}$

#### $AUC=\frac{1}{2}\sum^{m-1}_{i=1}(x_{i+1}-x_i)\cdot(y_i + y_{i+1})$



### 代价敏感错误率与代价曲线

在现实任务中常会遇到这样的情况：不同类型的错误所造成的后果不同. 例如在医疗诊断中，错误地把患者诊断为健康人与错误地把健康人诊断为患者, 看起来都是犯了“一次错误”，但后者的影响是增加了进一步检查的麻烦，前者的后果却可能是丧失了拯救生命的最佳时机；再如，门禁系统错误地把可通行人员拦在门外，将使得用户体验不佳,但错误地把陌生人放进门内，则会造成严重的安全事故.为权衡不同类型错误所造成的不同损失，可为错误赋予“非 均等代”（unequal cost).

以二分类任务为例，我们可根据任务的领域知识设定一个“代价矩阵”（cost matrix)，其中$cost_{ij}$表示将第i类样本预测为第j类样本的代价.一般来说，$cost_{ii} =0$;若将第0类判别为第1类所造成的损失更大，则$cost_{01} > cost_{10}$;损失程度相差越大，$cost_{01}$与$cost_{10}$值的差别越大.

![代价矩阵](http://eveseven.oss-cn-shanghai.aliyuncs.com/18-12-28/61524266.jpg)

#### 代价敏感（cost-sensitive）错误率$E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}\mathbb{I}(f(x_i) \ne y_i) \times cost_{01} + \sum_{x_i\in D^-}\mathbb{I}(f(x_i) \ne y_i) \times cost_{10} )$

转载请注明：[Seven的博客](http://sevenold.github.io)